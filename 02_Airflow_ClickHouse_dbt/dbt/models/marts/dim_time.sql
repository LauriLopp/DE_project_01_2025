{{
  config(
    materialized='table'
  )
}}

-- This CTE generates the complete hourly series.
-- It uses self-contained scalar subqueries to work around ClickHouse's scoping rules.
WITH all_times AS (
  SELECT
    toDateTime(
      -- Subquery 1: Get the starting timestamp. This is run once.
      (
        SELECT COALESCE(min(hour_start), now())
        FROM {{ ref('stg_iot_data') }}
      )
      + number * 3600 -- 'number' is generated by the numbers() function below
    ) AS timestamp
  FROM numbers(
    -- Subquery 2: Calculate the total number of hours to generate. This is run once.
    assumeNotNull(
      (
        SELECT dateDiff(
          'hour',
          COALESCE(min(hour_start), now()),
          COALESCE(max(hour_start), now())
        ) + 1
        FROM {{ ref('stg_iot_data') }}
      )
    )
  )
),

base_time AS (
  SELECT
    toDate(timestamp) AS FullDate,
    toYear(timestamp) AS Year,
    toMonth(timestamp) AS Month,
    toDayOfMonth(timestamp) AS Day,
    toDayOfWeek(timestamp) AS DayOfWeek,
    toHour(timestamp) AS HourOfDay,
    multiIf(
      Month IN (12, 1, 2), 'Winter',
      Month IN (3, 4, 5), 'Spring',
      Month IN (6, 7, 8), 'Summer',
      'Autumn'
    ) AS Season,
    DayOfWeek IN (6, 7) AS IsWeekend,
    HourOfDay IN (7, 8, 9, 17, 18, 19) AS IsPeakHour
  FROM all_times
),

holidays AS (
  SELECT
    toDate(timestamp) AS holiday_date
  FROM {{ ref('estonian_holidays') }}
)

SELECT
  row_number() OVER (ORDER BY bt.FullDate) AS TimeKey,
  bt.FullDate,
  bt.Year,
  bt.Month,
  bt.Day,
  bt.DayOfWeek,
  bt.HourOfDay,
  bt.Season,
  h.holiday_date IS NOT NULL AS IsHoliday,
  bt.IsWeekend,
  bt.IsPeakHour
FROM base_time AS bt
LEFT JOIN holidays AS h
  ON bt.FullDate = h.holiday_date