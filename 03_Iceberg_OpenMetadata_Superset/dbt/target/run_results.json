{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v5.json", "dbt_version": "1.7.9", "generated_at": "2025-11-02T23:11:44.816445Z", "invocation_id": "b8533568-796d-437b-a90d-3d2329f7b54f", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:42.865465Z", "completed_at": "2025-11-02T23:11:42.898458Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:42.905371Z", "completed_at": "2025-11-02T23:11:43.024351Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.16748738288879395, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.stg_device", "compiled": true, "compiled_code": "\n\n-- Staging: device model info from bronze bronze_iot_raw_data.bronze_device\nselect\n  row_number() over () as DeviceKey,\n  *\nfrom `default`.`bronze_device`", "relation_name": "`default`.`stg_device`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:43.053335Z", "completed_at": "2025-11-02T23:11:43.076768Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:43.084188Z", "completed_at": "2025-11-02T23:11:43.155297Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.11053037643432617, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.stg_iot_data", "compiled": true, "compiled_code": "\n\n-- Staging: transform long IoT readings into a wide table per hour with averages\n-- Contract:\n--   Input  (bronze_iot_raw_data): ingestion_ts DateTime, entity_id String, state String, last_changed DateTime, attributes String\n--   Output (view): one row per hour with average values per measurement\n-- Notes:\n--   - Values are cast to Float64 where possible (non-numeric -> NULL)\n--   - Aggregated to hourly averages using toStartOfHour()\n\nWITH base AS (\n\tSELECT\n\t\t-- Parse IoT timestamps (often ISO with 'Z') and convert to local time\n\t\ttoTimeZone(last_changed, 'Europe/Tallinn') as timestamp,\n\t\tentity_id,\n\t\ttoFloat64OrNull(state)                                                    AS value\n\tFROM `default`.`bronze_iot_raw_data`\n)\nSELECT\n\trow_number() over () as IoTKey,\n\ttoStartOfHour(timestamp) as hour_start,\n\t-- Power sensors (hourly averages)\n\tavgIf(value, entity_id = 'sensor.ohksoojus_power')                  AS heat_pump_power_avg,\n\tavgIf(value, entity_id = 'sensor.0xa4c138cdc6eff777_power')         AS boiler_power_avg,\n\tavgIf(value, entity_id = 'sensor.ohukuivati_power')                 AS air_drier_power_avg,\n\n\t-- Humidity (absolute and relative, hourly averages)\n\tavgIf(value, entity_id = 'sensor.abshumidkuu2_absolute_humidity')   AS living_room_hum_abs_avg,\n\tavgIf(value, entity_id = 'sensor.tempniiskuslauaall_humidity')      AS living_room_hum_perc_avg,\n\tavgIf(value, entity_id = 'sensor.indoor_absolute_humidity')         AS wc_hum_abs_avg,\n\n\t-- Temperatures (hourly averages)\n\tavgIf(value, entity_id = 'sensor.tempniiskuslauaall_temperature')   AS living_room_temp_avg,\n\tavgIf(value, entity_id = 'sensor.indoor_outdoor_meter_3866')        AS wc_temp_avg,\n\n\t-- Voltage sensors (hourly averages)\n\tavgIf(value, entity_id = 'sensor.0xa4c138cdc6eff777_voltage')       AS boiler_voltage_avg\nFROM base\nGROUP BY toStartOfHour(timestamp)", "relation_name": "`default`.`stg_iot_data`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:43.184055Z", "completed_at": "2025-11-02T23:11:43.222595Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:43.228083Z", "completed_at": "2025-11-02T23:11:43.278892Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.10909080505371094, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.stg_location", "compiled": true, "compiled_code": "\n\n-- Staging: device location SCD from bronze raw_data.location_data\nselect\n  row_number() over () as LocationKey,\n  *\nfrom `default`.`bronze_location`", "relation_name": "`default`.`stg_location`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:43.319177Z", "completed_at": "2025-11-02T23:11:43.350843Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:43.357604Z", "completed_at": "2025-11-02T23:11:43.439381Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.1320972442626953, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.stg_price_data", "compiled": true, "compiled_code": "\n\n-- Staging: clean electricity price data\n-- Requirements:\n-- 1) Meaningful column names\n-- 2) Consistently use local time (Europe/Tallinn) - already in bronze layer\n-- 3) Consistently use a DateTime column named `timestamp`\n-- 4) Numeric values as floats, convert EUR/MWh -> EUR/kWh\n-- 5) Aggregate to hourly averages if granularity is higher than hour\n\nWITH raw AS (\n\tSELECT\n\t\ttoTimeZone(ts_utc, 'Europe/Tallinn') AS timestamp_raw,\n\t\tprice_per_mwh AS price_eur_per_mwh\n\tFROM `default`.`bronze_elering_price`\n), aggregated AS (\n\tSELECT\n\t\ttoStartOfHour(timestamp_raw) AS timestamp,\n\t\tavg(price_eur_per_mwh) AS avg_price_eur_per_mwh\n\tFROM raw\n\tGROUP BY toStartOfHour(timestamp_raw)\n)\nSELECT\n\trow_number() over () as PriceKey,\n\ttimestamp,\n\t/* Convert EUR/MWh -> EUR/kWh */\n\tavg_price_eur_per_mwh / 1000.0 AS price_eur_per_kwh\nFROM aggregated\nWHERE timestamp IS NOT NULL", "relation_name": "`default`.`stg_price_data`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:43.515276Z", "completed_at": "2025-11-02T23:11:43.567614Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:43.573661Z", "completed_at": "2025-11-02T23:11:43.646350Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.14119291305541992, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.stg_weather_data", "compiled": true, "compiled_code": "\n\n-- Staging: clean weather data\n-- Goals:\n-- 1) English column names\n-- 2) Convert UTC timestamp to local time (Europe/Tallinn) and expose a DateTime column named `timestamp`\n-- 3) Cast numeric fields to floats and turn missing values into NULLs\n-- 4) Aggregate to hourly grain to match other data!!\n-- 5) Add surrogate key\n\nWITH raw AS (\n\tSELECT\n\t\ttoTimeZone(last_changed, 'Europe/Tallinn') AS timestamp_raw,\n\t\ttemperature_C       \t\tAS temperature_c,\n\t\tdew_point_C         \t\tAS dew_point_c,\n\t\thumidity_percent    \t\tAS humidity_perc,\n\t\tcloud_coverage_pct  \t\tAS cloud_coverage_pct,\n\t\tuv_index            \t\tAS uv_index,\n\t\tpressure_hPa * 0.750061683\tAS air_pressure_mmhg,\n\t\twind_bearing_deg    \t\tAS wind_direction_deg,\n\t\twind_gust_speed_kmh / 3.6\tAS wind_gust_speed_ms,\n\t\twind_speed_kmh / 3.6      \tAS wind_speed_ms,\n\t\tcondition_state            AS condition_state\n\tFROM `default`.`bronze_weather_history`\n),\n\naggregated AS (\n    SELECT\n        -- Truncate timestamp to the hour for aggregation\n        toStartOfHour(timestamp_raw) AS hourly_timestamp,\n        avg(temperature_c)       AS temperature_c,\n        avg(dew_point_c)         AS dew_point_c,\n        avg(humidity_perc)       AS humidity_perc,\n        avg(cloud_coverage_pct)  AS cloud_coverage_pct,\n        avg(uv_index)            AS uv_index,\n        avg(air_pressure_mmhg)   AS air_pressure_mmhg,\n        avg(wind_direction_deg)  AS wind_direction_deg,\n        avg(wind_gust_speed_ms)\t AS wind_gust_speed_ms,\n\t\tavg(wind_speed_ms)\t\t AS wind_speed_ms,\n        argMax(condition_state, timestamp_raw) AS condition_state\n    FROM raw\n    WHERE timestamp_raw IS NOT NULL\n    GROUP BY toStartOfHour(timestamp_raw)\n)\n\nSELECT\n\trow_number() over (order by hourly_timestamp) as WeatherKey,\n    hourly_timestamp as timestamp,\n    temperature_c,\n    dew_point_c,\n    humidity_perc,\n    cloud_coverage_pct,\n    uv_index,\n    air_pressure_mmhg,\n    wind_direction_deg,\n    wind_gust_speed_ms,\n    wind_speed_ms,\n    condition_state\nFROM aggregated", "relation_name": "`default`.`stg_weather_data`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:43.672668Z", "completed_at": "2025-11-02T23:11:43.701003Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:43.707287Z", "completed_at": "2025-11-02T23:11:43.998779Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.3393826484680176, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.dim_device", "compiled": true, "compiled_code": "\n\n-- Gold layer: DIM_DEVICE\n-- This dimension table is derived from the stg_device staging table.\n-- It includes the following columns:\n--   - DeviceKey: Primary key\n--   - Brand: Device brand (not null)\n--   - Model: Device model (not null)\n--   - MinPower: Minimum power of the device\n--   - InstallationDate: Date of installation (not null)\n--   - ValidTo: Validity end date (default '9999-12-31')\n\nSELECT\n  row_number() OVER () AS DeviceKey, -- Primary key\n  Brand,\n  Model,\n  MinPower,\n  InstallationDate,\n  COALESCE(ValidTo, toDate('9999-12-31')) AS ValidTo\nFROM `default`.`stg_device`\nWHERE Brand IS NOT NULL AND Model IS NOT NULL", "relation_name": "`default`.`dim_device`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:44.028845Z", "completed_at": "2025-11-02T23:11:44.076702Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:44.083711Z", "completed_at": "2025-11-02T23:11:44.346806Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.32695531845092773, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.dim_location", "compiled": true, "compiled_code": "\n\nSELECT\n  row_number() OVER () AS LocationKey,\n  DeviceLocation,\n  ClosestWeatherStation,\n  PricingRegion,\n  COALESCE(ValidFrom, toDate('2000-01-01')) AS ValidFrom,\n  COALESCE(ValidTo,   toDate('9999-12-31')) AS ValidTo\nFROM `default`.`stg_location`\nWHERE DeviceLocation IS NOT NULL\n  AND ClosestWeatherStation IS NOT NULL\n  AND PricingRegion IS NOT NULL", "relation_name": "`default`.`dim_location`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:44.375758Z", "completed_at": "2025-11-02T23:11:44.411310Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:44.416066Z", "completed_at": "2025-11-02T23:11:44.549697Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.18817353248596191, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.dim_time", "compiled": true, "compiled_code": "\n\n-- Gold-layer: DIM_TIME (sparse)\n-- Build only the hours actually used across staging sources (IoT, weather, price)\n\nWITH needed_hours AS (\n  SELECT toStartOfHour(hour_start) AS ts\n  FROM `default`.`stg_iot_data`\n  WHERE hour_start IS NOT NULL\n  UNION ALL\n  SELECT toStartOfHour(timestamp) AS ts\n  FROM `default`.`stg_weather_data`\n  WHERE timestamp IS NOT NULL\n  UNION ALL\n  SELECT toStartOfHour(timestamp) AS ts\n  FROM `default`.`stg_price_data`\n  WHERE timestamp IS NOT NULL\n),\ndistinct_hours AS (\n  SELECT DISTINCT ts FROM needed_hours\n),\nbase_time AS (\n  SELECT\n    ts,\n    toDate(ts)       AS FullDate,\n    toYear(ts)       AS Year,\n    toMonth(ts)      AS Month,\n    toDayOfMonth(ts) AS Day,\n    toDayOfWeek(ts)  AS DayOfWeek,\n    toHour(ts)       AS HourOfDay,\n    multiIf(\n      Month IN (12,1,2), 'Winter',\n      Month IN (3,4,5), 'Spring',\n      Month IN (6,7,8), 'Summer',\n      'Autumn'\n    ) AS Season,\n    DayOfWeek IN (6,7) AS IsWeekend,\n    HourOfDay IN (7,8,9,17,18,19) AS IsPeakHour\n  FROM distinct_hours\n),\nholidays AS (\n  SELECT toDate(timestamp) AS holiday_date\n  FROM `default`.`estonian_holidays`\n)\n\nSELECT\n  row_number() OVER (ORDER BY ts) AS TimeKey,\n  bt.FullDate,\n  bt.Year,\n  bt.Month,\n  bt.Day,\n  bt.DayOfWeek,\n  bt.HourOfDay,\n  bt.Season,\n  h.holiday_date IS NOT NULL AS IsHoliday,\n  bt.IsWeekend,\n  bt.IsPeakHour\nFROM base_time AS bt\nLEFT JOIN holidays AS h\n  ON bt.FullDate = h.holiday_date", "relation_name": "`default`.`dim_time`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-02T23:11:44.578829Z", "completed_at": "2025-11-02T23:11:44.609029Z"}, {"name": "execute", "started_at": "2025-11-02T23:11:44.613923Z", "completed_at": "2025-11-02T23:11:44.787487Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.21712350845336914, "adapter_response": {"_message": "OK"}, "message": "OK", "failures": null, "unique_id": "model.ac_energy_usage.fact_heating_energy_usage", "compiled": true, "compiled_code": "\n\n-- ============================================================================\n-- FACT_HEATING_ENERGY_USAGE\n-- ---------------------------------------------------------------------------\n-- Gold-layer fact table combining IoT sensor data, pricing, weather,\n-- device and location dimensions.\n-- Works fully in ClickHouse and uses CROSS JOIN + WHERE for range logic.\n-- ============================================================================\n\nWITH base AS (\n    SELECT\n        i.hour_start,\n        t.TimeKey,\n        p.price_eur_per_kwh           AS ElectricityPrice,\n        i.heat_pump_power_avg         AS ASHP_Power,\n        i.boiler_power_avg            AS Boiler_Power,\n        i.air_drier_power_avg         AS Air_Drier_Power,\n        i.boiler_voltage_avg          AS Boiler_Voltage,\n        i.living_room_temp_avg        AS IndoorTemp,\n        i.living_room_hum_perc_avg    AS IndoorHumidityPerc,\n        i.living_room_hum_abs_avg     AS IndoorHumidityAbs,\n        i.wc_hum_abs_avg              AS WC_HumidityAbs,\n        i.wc_temp_avg                 AS WC_Temp,\n        w.temperature_c               AS OutdoorTemp,\n        w.dew_point_c                 AS DewPoint,\n        w.humidity_perc               AS OutdoorHumidityPerc,\n        w.cloud_coverage_pct          AS CloudCoverage,\n        w.uv_index                    AS UV_Index,\n        w.air_pressure_mmhg           AS AirPressure_mmHg,\n        w.wind_direction_deg          AS WindDir,\n        w.wind_gust_speed_ms          AS WindGustSpeed_ms,\n        w.wind_speed_ms               AS WindSpeed_ms,\n        w.condition_state             AS WeatherCondition\n    FROM `default`.`stg_iot_data` AS i\n      JOIN `default`.`dim_time` AS t\n        ON i.hour_start = toDateTime(t.FullDate, 'Europe/Tallinn') + toIntervalHour(t.HourOfDay)\n    LEFT JOIN `default`.`stg_weather_data` AS w\n      ON i.hour_start = toStartOfHour(w.timestamp)\n    LEFT JOIN `default`.`stg_price_data` AS p\n      ON i.hour_start = toStartOfHour(p.timestamp)\n)\n\n-- ClickHouse-safe join logic\nSELECT\n  row_number() OVER (\n    ORDER BY b.TimeKey, d.DeviceKey, l.LocationKey\n  )                                          AS FactKey,\n    b.TimeKey,\n    d.DeviceKey,\n    l.LocationKey,\n    b.ElectricityPrice,\n    b.ASHP_Power,\n    b.Boiler_Power,\n    b.Air_Drier_Power,\n    b.Boiler_Voltage,\n    b.IndoorTemp,\n    b.IndoorHumidityPerc,\n    b.IndoorHumidityAbs,\n    b.WC_HumidityAbs,\n    b.WC_Temp,\n    b.OutdoorTemp,\n    b.DewPoint,\n    b.OutdoorHumidityPerc,\n    b.CloudCoverage,\n    b.UV_Index,\n    b.AirPressure_mmHg,\n    b.WindDir,\n    b.WindGustSpeed_ms,\n    b.WindSpeed_ms,\n    b.WeatherCondition\nFROM base AS b\nCROSS JOIN `default`.`dim_device` AS d\nCROSS JOIN `default`.`dim_location` AS l\nWHERE\n    -- Device validity window\n    toDate(b.hour_start)\n        BETWEEN toDate(COALESCE(d.InstallationDate, toDate('2000-01-01')))\n            AND toDate(COALESCE(d.ValidTo, toDate('9999-12-31')))\n    -- Location validity window\n    AND toDate(b.hour_start)\n        BETWEEN toDate(COALESCE(l.ValidFrom, toDate('2000-01-01')))\n            AND toDate(COALESCE(l.ValidTo,   toDate('9999-12-31')))", "relation_name": "`default`.`fact_heating_energy_usage`"}], "elapsed_time": 2.241985559463501, "args": {"log_file_max_bytes": 10485760, "partial_parse_file_diff": true, "which": "run", "log_path": "/dbt/logs", "favor_state": false, "profiles_dir": "/dbt", "write_json": true, "log_level": "info", "project_dir": "/dbt", "partial_parse": true, "show_resource_report": false, "log_format": "default", "select": [], "exclude": [], "invocation_command": "dbt run", "use_colors_file": true, "use_colors": true, "defer": false, "quiet": false, "vars": {}, "cache_selected_only": false, "send_anonymous_usage_stats": true, "strict_mode": false, "enable_legacy_logger": false, "macro_debugging": false, "log_format_file": "debug", "warn_error_options": {"include": [], "exclude": []}, "introspect": true, "static_parser": true, "log_level_file": "debug", "indirect_selection": "eager", "printer_width": 80, "version_check": true, "populate_cache": true, "print": true}}